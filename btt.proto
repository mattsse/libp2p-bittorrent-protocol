syntax = "proto3";
package structs.pb;

message MetaInfo {

    // represents a single file which is part of a directory structure
    message FileInfo {

        // The length of the file, in bytes.
        uint32 length = 1;

        // A list of UTF-8 encoded strings corresponding to subdirectory names, the last of which is the actual file name.
        // a zero length list is an error case.
        repeated string paths = 2;
    }

    // The URL of the tracker.
    string annouce = 1;

    // A UTF-8 encoded string which is the suggested name to save the file (or directory) as
    // In the single file case, the name key is the name of a file,
    // in the muliple file case, it's the name of a directory.
    string name = 2;

    // The number of bytes in each piece the file is split into.
    // is almost always a power of two
    uint32 piece_length = 3;

    // maps to a string whose length is a multiple of 20.
    // It is to be subdivided into strings of length 20, each of which is the SHA1 hash of the piece at the
    // corresponding index.
    string pieces = 4;

    // The length of the file in bytes.
    // only single file
    uint32 length = 5;

    // only multiple files
    repeated FileInfo files = 6;

};

message Peer {
    // ID of a given peer of length 20 which this downloader
    bytes id = 1;

    // An optional parameter giving the IP (or dns name) which this peer is at.
    // Generally used for the origin if it's on the same machine as the tracker.
    bytes ip = 2;

    // The port number this peer is listening on.
    uint32 port = 3;

};

message TrackerRequest {

    enum EventType {
        EMPTY = 0;
        STARTED = 1;
        COMPLETED = 2;
        STOPPED = 3;
    }

    // The 20 byte sha1 hash of the bencoded form of the info value from the metainfo file.
    bytes infoHash = 1;

    Peer peer = 2;

    // The total amount uploaded so far
    bytes uploaded = 3;

    // The total amount downloaded so far, encoded in base ten ascii.
    bytes downloaded = 4;

    // The number of bytes this peer still has to download.
    bytes left = 5;

    EventType event = 6;

};

message TrackerResponse {

    // when the query failed
    string failure_reason = 1;

    // the number of seconds the downloader should wait between regular rerequests.
    uint32 interval = 2;

    // matching peers
    repeated Peer peers = 3;

};

// messages for the peer protocol
message PeerMessage {
    enum MessageType {
        CHOKE = 0;
        UN_CHOKE = 1;
        INTERESTED = 2;
        NOT_INTERESTED = 3;
        HAVE = 4;
        BITFIELD = 5;
        REQUEST = 6;
        PIECE = 7;
        CANCEL = 8;
    }

    message Request {

        uint32 index = 1;

        // byte offset
        uint32 begin = 2;

        // length in power of 2, unless it gets truncated by the end of the file
        // All current implementations use 2^14 (16 kiB) and close connections which request an amount greater than that.
        uint32 length = 3;
    }

    message Piece {

        uint32 index = 1;

        // byte offset
        uint32 begin = 2;

        bytes piece = 3;
    }

    // defines what type of message it is.
    MessageType type = 1;

    // only ever sent as the first message
    // a bitfield with each index that downloader has sent set to one and the rest set to zero.
    // Downloaders which don't have anything yet may skip the 'bitfield' message.
    // The first byte of the bitfield corresponds to indices 0 - 7 from high bit to low bit, respectively.
    // The next one 8-15, etc. Spare bits at the end are set to zero.
    // BITFIELD
    bytes payload = 2;

    // the index which that downloader just completed and checked the hash of.
    // HAVE
    uint32 have_index = 4;

    // REQUEST, CANCEL
    Request request = 5;

    // PIECE
    Piece piece = 6;
};