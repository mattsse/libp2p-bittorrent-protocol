syntax = "proto3";
package structs.pb;

message MetaInfo {

    // represents a single file which is part of a directory structure
    message FileInfo {

        // The length of the file, in bytes.
        uint64 length = 1;

        // A list of UTF-8 encoded strings corresponding to subdirectory names, the last of which is the actual file name.
        // a zero length list is an error case.
        repeated string paths = 2;
    }

    // The URL of the tracker.
    string annouce_url = 1;

    // A UTF-8 encoded string which is the suggested name to save the file (or directory) as
    // In the single file case, the name key is the name of a file,
    // in the muliple file case, it's the name of a directory.
    string name = 2;

    // The number of bytes in each piece the file is split into.
    // is almost always a power of two
    uint32 piece_length = 3;

    // maps to a string whose length is a multiple of 20.
    // It is to be subdivided into strings of length 20, each of which is the SHA1 hash of the piece at the
    // corresponding index.
    repeated bytes pieces = 4;

    // The length of the file in bytes.
    // only single file
    uint64 length = 5;

    // only multiple files
    repeated FileInfo files = 6;

};

message Peer {
    // ID of a given peer.
    bytes id = 1;

    // multiaddrs for a given peer
    repeated bytes addrs = 2;

};

message TrackerRequest {

    enum EventType {
        EMPTY = 0;
        STARTED = 1;
        COMPLETED = 2;
        STOPPED = 3;
    }

    // The 20 byte sha1 hash of the bencoded form of the info value from the metainfo file.
    bytes info_hash = 1;

    Peer peer = 2;

    // The total amount uploaded so far
    uint64 uploaded = 3;

    // The total amount downloaded so far, encoded in base ten ascii.
    uint64 downloaded = 4;

    // The number of bytes this peer still has to download.
    uint64 left = 5;

    // Optional. Number of peers that the client would like to receive from the tracker.
    // This value is permitted to be zero. If omitted, typically defaults to 50 peers.
    uint32 numwant = 6;

    // optional event type
    EventType event = 7;

};

message TrackerResponse {

    enum TrackerResponseType {
        FAILURE = 0;
        SUCCESS = 1;
    }

    TrackerResponseType type = 1;

    // when the query failed
    string failure_reason = 2;

    // number of peers with the entire file, i.e. seeders
    uint32 complete = 3;

    // number of non-seeder peers, aka "leechers"
    uint32 incomplete = 4;

    // the number of seconds the downloader should wait between regular rerequests.
    uint32 interval = 5;

    // Minimum announce interval.
    // If present clients must not reannounce more frequently than this
    uint32 min_interval = 6;

    // matching peers
    repeated Peer peers = 7;
};

// messages for the peer protocol
message PeerMessage {
    enum MessageType {
        CHOKE = 0;
        UN_CHOKE = 1;
        INTERESTED = 2;
        NOT_INTERESTED = 3;
        HAVE = 4;
        BITFIELD = 5;
        REQUEST = 6;
        PIECE = 7;
        CANCEL = 8;
    }

    message Request {

        uint32 index = 1;

        // byte offset
        uint32 begin = 2;

        // length in power of 2, unless it gets truncated by the end of the file
        // All current implementations use 2^14 (16 kiB) and close connections which request an amount greater than that.
        uint32 length = 3;
    }

    message Piece {

        uint32 index = 1;

        // byte offset
        uint32 begin = 2;

        bytes piece = 3;
    }

    // defines what type of message it is.
    MessageType type = 1;

    // only ever sent as the first message
    // a bitfield with each index that downloader has sent set to one and the rest set to zero.
    // Downloaders which don't have anything yet may skip the 'bitfield' message.
    // The first byte of the bitfield corresponds to indices 0 - 7 from high bit to low bit, respectively.
    // The next one 8-15, etc. Spare bits at the end are set to zero.
    // BITFIELD
    bytes index_field = 2;

    // the index which that downloader just completed and checked the hash of.
    // HAVE
    uint32 have_index = 4;

    // REQUEST, CANCEL
    Request request = 5;

    // PIECE
    Piece piece = 6;
};